<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Agar-klón — NPC ellenségekkel</title>
<style>
:root{--bg:#111;--panel:#222;--text:#fff;--accent:#3aa;--danger:#e44;}
html,body{height:100%;margin:0;background:var(--panel);color:var(--text);font-family:Arial,Helvetica,sans-serif}
.container{max-width:1400px;margin:10px auto;padding:6px;}
#topbar{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:6px}
#hud{display:flex;gap:12px;align-items:center}
button{padding:6px 10px;border-radius:6px;border:none;background:#444;color:white;cursor:pointer}
.small{font-size:13px;opacity:0.95}
canvas{display:block;margin:8px auto;border:2px solid rgba(255,255,255,0.06);background:var(--bg);touch-action:none}
#controlsDesc{font-size:13px;opacity:0.9}
#minimap{position:absolute;right:18px;bottom:18px;width:180px;height:120px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.25);padding:6px}
#overlayButtons{position:fixed;right:18px;top:120px;display:flex;flex-direction:column;gap:8px}
.overlayBtn{width:64px;height:44px;border-radius:8px;background:#444;color:#fff;border:none;opacity:0.95}
.scoreboard{position:absolute;left:18px;top:18px;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;font-size:13px}
.touchInfo{position:fixed;left:50%;transform:translateX(-50%);bottom:6px;background:rgba(0,0,0,0.2);padding:6px;border-radius:6px;font-size:12px}
@media(max-width:700px){
    #minimap{width:120px;height:80px;right:8px;bottom:8px}
    .scoreboard{left:8px;top:8px}
}
</style>
</head>
<body>
<div class="container">
    <div id="topbar">
        <div id="hud">
            <div>J1 (kék): <span id="score1">0</span></div>
            <div>J2 (piros): <span id="score2">0</span></div>
            <div id="controlsDesc" class="small">J1: W A S D (mozog) • Space: split • Q: eject • J2: Nyilak • RShift: eject • Enter: split</div>
        </div>
        <div>
            <button id="fullscreenBtn">Fullscreen</button>
            <button id="pauseBtn">Szünet</button>
            <button id="resetBtn">Reset</button>
            <label class="small" style="margin-left:8px">Foods:
                <input id="foodCountInput" type="number" min="200" step="200" value="8000" style="width:90px">
            </label>
        </div>
    </div>

    <div style="position:relative;">
        <canvas id="gameCanvas"></canvas>
        <div id="minimap"></div>
        <div class="scoreboard" id="scoreboardEl">Top: —</div>
    </div>
    <div id="overlayButtons">
        <button class="overlayBtn" id="splitBtn">SPLIT</button>
        <button class="overlayBtn" id="ejectBtn">EJECT</button>
    </div>
    <div class="touchInfo small">Érintés: bal oldalon mozgatás, jobb oldalon split/eject gombok</div>
</div>

<script>
/* -----------------------
  Agar-klón NPC ellenségekkel
  ----------------------- */

/* ---------- KONFIG ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapEl = document.getElementById('minimap');
const sbEl = document.getElementById('scoreboardEl');
const score1El = document.getElementById('score1');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const foodCountInput = document.getElementById('foodCountInput');
const splitBtn = document.getElementById('splitBtn');
const ejectBtn = document.getElementById('ejectBtn');

let worldWidth = 50000, worldHeight = 50000;
let foodCount = parseInt(foodCountInput.value,10) || 8000;
let GRID_SIZE = 220;

const MAX_PLAYER_RADIUS = 380;
const MIN_PLAYER_RADIUS = 12;
const NPC_COUNT = 15; // NPC ellenségek száma

/* ---------- HELPEREK ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; }
function nowMs(){ return performance.now(); }
function rand(min,max){ return min + Math.random()*(max-min); }
function int(n){ return Math.floor(n); }

/* ---------- CANVAS RESIZE ---------- */
function resizeCanvas(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const availW = Math.min(window.innerWidth - 40, 1400);
    const availH = Math.min(window.innerHeight - 140, 900);
    const targetW = Math.max(680, Math.round(availW));
    const targetH = Math.max(420, Math.round(availH));
    canvas.style.width = targetW + 'px';
    canvas.style.height = targetH + 'px';
    canvas.width = Math.round(targetW * dpr);
    canvas.height = Math.round(targetH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- SPATIAL GRID & POOLS ---------- */
let cellCols = Math.ceil(worldWidth / GRID_SIZE);
let cellRows = Math.ceil(worldHeight / GRID_SIZE);
let grid = Array.from({length:cellCols*cellRows}, ()=>[]);

// pooling for foods & pellets & fragments
const foodPool = [];
const pelletPool = [];
const fragmentPool = [];

function ensurePools(){
    // foods pool (we'll fill exactly foodCount on init)
    for(let i=0;i<foodCount;i++){
        foodPool.push({type:'food', x:0,y:0,radius:5, _cell:-1});
    }
    // pellets small (for eject)
    for(let i=0;i<200;i++) pelletPool.push({type:'pellet', x:0,y:0,radius:3, vx:0,vy:0, life:0, _cell:-1});
    // fragments for split
    for(let i=0;i<200;i++) fragmentPool.push({type:'frag', owner:null, x:0,y:0, radius:0, vx:0,vy:0, life:0, merging:false, _cell:-1});
}

function cellIndexFor(x,y){
    if (isNaN(x) || isNaN(y)) {
        console.error('Invalid coordinates for cellIndexFor:', { x, y });
        return 0;
    }
    const cx = clamp(Math.floor(x / GRID_SIZE), 0, cellCols - 1);
    const cy = clamp(Math.floor(y / GRID_SIZE), 0, cellRows - 1);
    const idx = cy * cellCols + cx;
    if (idx < 0 || idx >= grid.length) {
        console.error('Invalid grid index:', { idx, x, y, cellCols, cellRows });
        return 0;
    }
    return idx;
}

function addToCell(obj){
    const idx = cellIndexFor(obj.x,obj.y);
    if (!grid || !grid[idx]) {
        console.error('Grid cell is undefined:', { idx, gridLength: grid?.length });
        return;
    }
    obj._cell = idx;
    grid[idx].push(obj);
}
function removeFromCell(obj){
    const idx = obj._cell;
    if(typeof idx !== 'number') return;
    const arr = grid[idx];
    const pos = arr.indexOf(obj);
    if(pos >= 0) arr.splice(pos,1);
    obj._cell = -1;
}
function moveToCell(obj, newX, newY){
    // remove from old cell (fast-ish)
    const old = obj._cell;
    if(typeof old === 'number' && old >=0){
        const arr = grid[old];
        const p = arr.indexOf(obj);
        if(p>=0) arr.splice(p,1);
    }
    obj.x = newX; obj.y = newY;
    const idx = cellIndexFor(newX,newY);
    obj._cell = idx;
    grid[idx].push(obj);
}

/* ---------- ENTITIES ---------- */
let foods = []; // references to foodPool entries currently active
let pellets = []; // active pellets
let fragments = []; // active split pieces
let npcs = []; // NPC ellenségek

// players (keep as simple single-entity plus fragments)
function makePlayer(x,y,color){
    return {
        x,y,
        radius:20,
        baseSpeed:5,
        boost:1, boostUntil:0,
        flashUntil:0,
        color,
        score:0,
        id: Math.random().toString(36).slice(2,9)
    };
}

// NPC létrehozása
function makeNPC(){
    const colors = ['#8f4', '#f84', '#48f', '#f8f', '#8ff', '#ff8'];
    const x = Math.random() * worldWidth;
    const y = Math.random() * worldHeight;
    const npc = {
        x, y,
        radius: 15 + Math.random() * 15,
        baseSpeed: 2 + Math.random() * 1, // Csökkentett sebesség: 2 és 3 között
        targetX: x,
        targetY: y,
        targetChangeTime: 0,
        color: colors[Math.floor(Math.random() * colors.length)],
        score: 0,
        id: 'npc_' + Math.random().toString(36).slice(2,7)
    };
    if (isNaN(npc.x) || isNaN(npc.y)) {
        console.error('Érvénytelen NPC koordináták inicializáláskor:', npc);
        npc.x = worldWidth / 2;
        npc.y = worldHeight / 2;
        npc.targetX = npc.x;
        npc.targetY = npc.y;
    }
    return npc;
}

let player1 = makePlayer(worldWidth*0.25, worldHeight*0.5,'blue');

/* ---------- INICIALIZÁLÁS ---------- */
ensurePools();

function initGrid(){
    cellCols = Math.ceil(worldWidth / GRID_SIZE);
    cellRows = Math.ceil(worldHeight / GRID_SIZE);
    if (cellCols <= 0 || cellRows <= 0 || isNaN(cellCols) || isNaN(cellRows)) {
        console.error('Invalid grid dimensions:', { cellCols, cellRows, worldWidth, worldHeight, GRID_SIZE });
        cellCols = Math.max(1, cellCols);
        cellRows = Math.max(1, cellRows);
    }
    grid = Array.from({length: cellCols * cellRows}, () => []);
    console.log('Grid initialized:', { cellCols, cellRows, gridLength: grid.length });
}

function spawnFoods(count){
    foods.length = 0;
    for(let i=0;i<count;i++){
        const f = foodPool[i];
        const r = 5;
        const x = r + Math.random()*(worldWidth - 2*r);
        const y = r + Math.random()*(worldHeight - 2*r);
        f.x = x; f.y = y; f.radius = r; f.type='food';
        addToCell(f);
        foods.push(f);
    }
}

// NPC-k inicializálása
function initNPCs(){
    npcs = [];
    for(let i=0; i<NPC_COUNT; i++){
        const npc = makeNPC();
        npc._cell = -1; // Initialize _cell
        addToCell(npc); // Add to grid
        npcs.push(npc);
        console.log('NPC létrehozva:', npc);
    }
    console.log('Összes NPC:', npcs.length);
}

/* ---------- POWER-UPS ---------- */
const powerups = []; // active powerups in world
const powerupPool = [];
function initPowerupPool(){
    for(let i=0;i<80;i++) powerupPool.push({type:'power', kind:'speed', x:0,y:0,radius:9,_cell:-1,life:0});
}
initPowerupPool();
function spawnPowerup(){
    if(Math.random() > 0.28) return;
    const kinds = ['speed','shield','mass'];
    const p = powerupPool.pop();
    if(!p) return;
    p.kind = kinds[int(Math.random()*kinds.length)];
    p.radius = 9;
    p.x = p.radius + Math.random()*(worldWidth - 2*p.radius);
    p.y = p.radius + Math.random()*(worldHeight - 2*p.radius);
    p.life = nowMs() + 30_000; // 30s on ground
    p._cell = -1;
    addToCell(p);
    powerups.push(p);
}

/* ---------- UTIL: query nearby objects ---------- */
function queryNearby(x,y,radius){
    const minCx = clamp(Math.floor((x - radius) / GRID_SIZE), 0, cellCols-1);
    const maxCx = clamp(Math.floor((x + radius) / GRID_SIZE), 0, cellCols-1);
    const minCy = clamp(Math.floor((y - radius) / GRID_SIZE), 0, cellRows-1);
    const maxCy = clamp(Math.floor((y + radius) / GRID_SIZE), 0, cellRows-1);
    const res = [];
    for(let cy=minCy; cy<=maxCy; cy++){
        const base = cy * cellCols;
        for(let cx=minCx; cx<=maxCx; cx++){
            const cell = grid[base + cx];
            if(cell && cell.length){
                for(const o of cell) res.push(o);
            }
        }
    }
    return res;
}

/* ---------- INPUT ---------- */
const keys = {};
document.addEventListener('keydown', e=>{
    const k = e.key;
    if(k.startsWith('Arrow')) e.preventDefault();
    if(k===' '){ e.preventDefault(); keys['space']=true; }
    keys[k.toLowerCase()] = true;
});
document.addEventListener('keyup', e=>{
    const k = e.key;
    keys[k.toLowerCase()] = false;
    if(k===' ') keys['space'] = false;
});

// fullscreen
fullscreenBtn.addEventListener('click', ()=> {
    if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
});

// pause/reset
let paused = false;
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Folytat' : 'Szünet'; if(!paused) lastTime = nowMs(); });
resetBtn.addEventListener('click', ()=>{ startGame(); });

// HUD inputs
foodCountInput.addEventListener('change', ()=>{ const v = parseInt(foodCountInput.value,10); if(v>0){ foodCount=v; startGame(); } });

// overlay touch buttons
splitBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); doSplit(player1); });
ejectBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); doEject(player1); });

// basic gamepad support (polling)
let haveGamepad = false;
window.addEventListener("gamepadconnected", ()=>{ haveGamepad = true; });
window.addEventListener("gamepaddisconnected", ()=>{ haveGamepad = false; });

/* ---------- TOUCH MOVE (simple) ---------- */
let touchState = { active:false, tx:0, ty:0 };
canvas.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchState.active = true;
    touchState.tx = (t.clientX - rect.left) * (canvas.width / rect.width);
    touchState.ty = (t.clientY - rect.top) * (canvas.height / rect.height);
});
canvas.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchState.tx = (t.clientX - rect.left) * (canvas.width / rect.width);
    touchState.ty = (t.clientY - rect.top) * (canvas.height / rect.height);
});
canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); touchState.active=false; });

/* ---------- MOVEMENT & PHYSICS ---------- */
function effectiveSpeed(player) {
    const sizeFactor = Math.max(1, player.radius / 20);
    const speed = Math.min(6, (player.baseSpeed / Math.sqrt(sizeFactor)) * (player.boost || 1)); // Max sebesség 6
    if (speed < 0.5) {
        console.warn('Túl alacsony sebesség:', { speed, radius: player.radius, baseSpeed: player.baseSpeed });
        return 0.5; // Minimum sebesség
    }
    return speed;
}

/* ---------- GAME MECHANICS: split / eject / growth ---------- */
function doSplit(player){
    if(player.radius < 28) return;
    // take half radius for fragment
    const fragR = Math.max(8, Math.floor(player.radius/2));
    player.radius = Math.max(MIN_PLAYER_RADIUS, player.radius - fragR);
    // get fragment from pool
    const frag = fragmentPool.pop();
    if(!frag) return;
    frag.owner = player;
    frag.radius = fragR;
    frag.x = player.x + fragR + 2;
    frag.y = player.y;
    // direction - player's facing approximated from keys or towards mouse (we'll use last input vector)
    const dir = getInputDirection();
    const mag = Math.hypot(dir.x, dir.y) || 1;
    frag.vx = (dir.x / mag) * (8 + fragR/6);
    frag.vy = (dir.y / mag) * (8 + fragR/6);
    frag.life = nowMs() + 6000; // 6s active before can merge
    frag.merging = false;
    fragments.push(frag);
    addToCell(frag);
}

function doEject(player){
    if(player.radius < 16) return;
    const amt = Math.max(2, Math.floor(player.radius*0.06));
    player.radius = Math.max(MIN_PLAYER_RADIUS, player.radius - amt);
    const p = pelletPool.pop();
    if(!p) return;
    p.radius = 3;
    p.x = player.x + (player.radius + 8);
    p.y = player.y;
    const dir = getInputDirection();
    const mag = Math.hypot(dir.x, dir.y) || 1;
    p.vx = (dir.x / mag) * 6;
    p.vy = (dir.y / mag) * 6;
    p.life = nowMs() + 4000;
    pellets.push(p);
    addToCell(p);
}

/* ---------- NPC AI ---------- */
function updateNPCs(dt) {
    const now = nowMs();
    const maxStep = 5; // Nagyobb lépésméret: 5 pixel/update

    for (const npc of npcs) {
        if (isNaN(npc.x) || isNaN(npc.y)) {
            console.warn('NPC koordinátái NaN, visszaállítás:', npc);
            npc.x = Math.random() * worldWidth;
            npc.y = Math.random() * worldHeight;
            npc.targetX = npc.x;
            npc.targetY = npc.y;
            npc.targetChangeTime = now + 2000 + Math.random() * 3000;
            addToCell(npc);
            continue;
        }

        let moveX = 0, moveY = 0;
        let moved = false;

        // 1. Játékos elkerülése (csak player1)
        const pdx = npc.x - player1.x;
        const pdy = npc.y - player1.y;
        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
        if (pdist < player1.radius + npc.radius + 200 && pdist > 0) {
            const avoidSpeed = effectiveSpeed(npc) * (dt / 16.6667) * 1.5; // Gyorsabb elkerülés
            moveX = (pdx / pdist) * avoidSpeed;
            moveY = (pdy / pdist) * avoidSpeed;
            if (isNaN(moveX) || isNaN(moveY)) {
                console.warn('NaN a játékos elkerülésében:', { pdx, pdy, pdist });
                moveX = 0;
                moveY = 0;
            } else {
                moved = true;
                console.log('NPC kerüli a játékost:', { npcId: npc.id, moveX, moveY, pdist });
            }
        }

        // 2. Étel keresése, ha nem kerülünk játékost
        if (!moved) {
            const nearby = queryNearby(npc.x, npc.y, npc.radius + 150); // Nagyobb keresési távolság
            let closestFood = null;
            let closestDist = Infinity;
            for (const obj of nearby) {
                if (obj.type === 'food') {
                    const d = dist2(npc.x, npc.y, obj.x, obj.y);
                    if (d < closestDist) {
                        closestDist = d;
                        closestFood = obj;
                    }
                }
            }
            if (closestFood) {
                const fdx = closestFood.x - npc.x;
                const fdy = closestFood.y - npc.y;
                const fdist = Math.sqrt(fdx * fdx + fdy * fdy);
                if (fdist > 0) {
                    const speed = effectiveSpeed(npc) * (dt / 16.6667) * 1.2; // Gyorsabb ételkeresés
                    moveX = (fdx / fdist) * speed;
                    moveY = (fdy / fdist) * speed;
                    if (isNaN(moveX) || isNaN(moveY)) {
                        console.warn('NaN az étel keresésében:', { fdx, fdy, fdist });
                        moveX = 0;
                        moveY = 0;
                    } else {
                        moved = true;
                        console.log('NPC étel felé mozog:', { npcId: npc.id, moveX, moveY, fdist });
                    }
                }
            }
        }

        // 3. Véletlenszerű mozgás, ha nincs más cél
        if (!moved) {
            if (now > npc.targetChangeTime ||
                Math.abs(npc.x - npc.targetX) < 20 && Math.abs(npc.y - npc.targetY) < 20) {
                const maxTargetDist = 300; // Nagyobb célpont távolság
                const angle = Math.random() * Math.PI * 2;
                npc.targetX = npc.x + Math.cos(angle) * maxTargetDist * (0.5 + Math.random() * 0.5); // Minimum 150px távolság
                npc.targetY = npc.y + Math.sin(angle) * maxTargetDist * (0.5 + Math.random() * 0.5);
                npc.targetX = clamp(npc.targetX, npc.radius, worldWidth - npc.radius);
                npc.targetY = clamp(npc.targetY, npc.radius, worldHeight - npc.radius);
                npc.targetChangeTime = now + 3000 + Math.random() * 4000; // Hosszabb idő új célpontig
                console.log('Új célpont generálva NPC-nek:', { npcId: npc.id, targetX: npc.targetX, targetY: npc.targetY });
            }
            const dx = npc.targetX - npc.x;
            const dy = npc.targetY - npc.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
                const speed = effectiveSpeed(npc) * (dt / 16.6667) * 1.1; // Enyhén gyorsabb véletlenszerű mozgás
                moveX = (dx / dist) * speed;
                moveY = (dy / dist) * speed;
                if (isNaN(moveX) || isNaN(moveY)) {
                    console.warn('NaN a véletlenszerű mozgásban:', { dx, dy, dist });
                    moveX = 0;
                    moveY = 0;
                } else {
                    moved = true;
                    console.log('NPC véletlenszerűen mozog:', { npcId: npc.id, moveX, moveY, dist });
                }
            }
        }

        // Kis véletlenszerű mozgás csak végső esetben
        if (!moved) {
            const randomStep = maxStep * 0.3; // Csökkentett amplitúdó
            moveX = (Math.random() - 0.5) * randomStep;
            moveY = (Math.random() - 0.5) * randomStep;
            console.log('Kis véletlenszerű mozgás:', { npcId: npc.id, moveX, moveY });
        }

        // Lépésméret korlátozása
        const totalDist = Math.sqrt(moveX * moveX + moveY * moveY);
        if (totalDist > maxStep) {
            moveX = (moveX / totalDist) * maxStep;
            moveY = (moveY / totalDist) * maxStep;
            console.log('Lépésméret korlátozva:', { npcId: npc.id, moveX, moveY, totalDist });
        }

        // Pozíció frissítése és világ határain belül tartás
        if (!isNaN(moveX) && !isNaN(moveY)) {
            npc.x += moveX;
            npc.y += moveY;
            npc.x = clamp(npc.x, npc.radius, worldWidth - npc.radius);
            npc.y = clamp(npc.y, npc.radius, worldHeight - npc.radius);
            console.log('NPC pozíció frissítve:', { npcId: npc.id, x: npc.x, y: npc.y });
        } else {
            console.warn('Pozíciófrissítés kihagyva NaN miatt:', { moveX, moveY, npc });
        }

        // Cella frissítése
        const idx = cellIndexFor(npc.x, npc.y);
        if (idx !== npc._cell) {
            removeFromCell(npc);
            addToCell(npc);
            console.log('NPC cella frissítve:', { npcId: npc.id, newCell: idx });
        }
    }
}

/* ---------- INPUT DIRECTION helper ---------- */
function getInputDirection(){
    let dx=0,dy=0;
    if(keys['w']) dy -= 1;
    if(keys['s']) dy += 1;
    if(keys['a']) dx -= 1;
    if(keys['d']) dx += 1;
    if(touchState.active){
        // convert touch pos to world coords and aim
        const tx = touchState.tx;
        const ty = touchState.ty;
        const worldX = camX + tx;
        const worldY = camY + ty;
        dx = worldX - player1.x; dy = worldY - player1.y;
    }
    // gamepad override
    if(haveGamepad){
        const gp = navigator.getGamepads()[0];
        if(gp){
            const ax = gp.axes[0] || 0, ay = gp.axes[1] || 0;
            if(Math.abs(ax) > 0.12 || Math.abs(ay) > 0.12){ dx = ax; dy = ay; }
        }
    }
    return {x:dx,y:dy};
}

/* ---------- COLLISIONS / UPDATES ---------- */
function updateEntities(dt){
    // NPC-k frissítése
    updateNPCs(dt);
    
    // move pellets
    for(let i=pellets.length-1;i>=0;i--){
        const p = pellets[i];
        if(!p) continue;
        // simple Euler
        p.x += p.vx * (dt/16.6667);
        p.y += p.vy * (dt/16.6667);
        // update cell
        const idx = cellIndexFor(p.x,p.y);
        if(idx !== p._cell){
            removeFromCell(p);
            addToCell(p);
        }
        if(nowMs() > p.life){
            // remove to pool
            removeFromCell(p);
            pelletPool.push(p);
            pellets.splice(i,1);
        }
    }

    // move fragments
    for(let i=fragments.length-1;i>=0;i--){
        const f = fragments[i];
        f.x += f.vx * (dt/16.6667);
        f.y += f.vy * (dt/16.6667);
        // damping
        f.vx *= 0.995; f.vy *= 0.995;
        const idx = cellIndexFor(f.x,f.y);
        if(idx !== f._cell){ removeFromCell(f); addToCell(f); }
        // life check -> allow merging after life expired
        if(nowMs() > f.life) f.merging = true;
        // if merging and close to owner -> merge
        if(f.merging && f.owner){
            const d2 = dist2(f.x,f.y,f.owner.x,f.owner.y);
            if(d2 < (f.radius + f.owner.radius + 6) ** 2){
                // merge sizes
                f.owner.radius = Math.min(MAX_PLAYER_RADIUS, Math.sqrt(f.owner.radius*f.owner.radius + f.radius*f.radius));
                removeFromCell(f);
                fragmentPool.push(f);
                fragments.splice(i,1);
                continue;
            }
        }
        // if out of world -> recycle
        if(f.x < -100 || f.x > worldWidth+100 || f.y < -100 || f.y > worldHeight+100){
            removeFromCell(f);
            fragmentPool.push(f);
            fragments.splice(i,1);
        }
    }

    // power-ups lifetime
    for(let i=powerups.length-1;i>=0;i--){
        const p = powerups[i];
        if(nowMs() > p.life){
            removeFromCell(p);
            powerupPool.push(p);
            powerups.splice(i,1);
        }
    }
}

function checkCollisions(){
    // Játékos ételek, power-upok és pelletek felvétele
    handlePlayerPickup(player1);
    
    // NPC-k ételek és power-upok felvétele
    for(const npc of npcs){
        if(isNaN(npc.x) || isNaN(npc.y)){
            console.warn('NPC koordinátái NaN, visszaállítás:', npc);
            const idx = npcs.indexOf(npc);
            npcs.splice(idx, 1);
            npcs.push(makeNPC());
            continue;
        }
        handleNPCPickup(npc);
    }

    // Fragmentumok és pelletek ütközései
    for(const frag of fragments){
        if(isNaN(frag.x) || isNaN(frag.y)){
            console.warn('Fragmentum koordinátái NaN, visszaállítás:', frag);
            const idx = fragments.indexOf(frag);
            fragments.splice(idx, 1);
            continue;
        }
        const near = queryNearby(frag.x, frag.y, frag.radius + 8);
        for(const o of near){
            if(o.type === 'food'){
                const rsum = frag.radius + o.radius;
                if(dist2(frag.x, frag.y, o.x, o.y) < rsum*rsum){
                    frag.radius = Math.min(MAX_PLAYER_RADIUS, frag.radius + 0.7);
                    moveToRandomFood(o);
                }
            } else if(o.type === 'pellet'){
                const rsum = frag.radius + o.radius;
                if(dist2(frag.x, frag.y, o.x, o.y) < rsum*rsum){
                    frag.radius = Math.min(MAX_PLAYER_RADIUS, frag.radius + 0.6);
                    removeFromCell(o);
                    const idx = pellets.indexOf(o);
                    if(idx >= 0) pellets.splice(idx, 1);
                    pelletPool.push(o);
                }
            } else if(o.type === 'power'){
                const rsum = frag.radius + o.radius;
                if(dist2(frag.x, frag.y, o.x, o.y) < rsum*rsum){
                    frag.radius = Math.min(MAX_PLAYER_RADIUS, frag.radius + 3);
                    removeFromCell(o);
                    powerupPool.push(o);
                    const pi = powerups.indexOf(o);
                    if(pi >= 0) powerups.splice(pi, 1);
                }
            }
        }
    }

    // Pelletek ütközése játékosokkal és NPC-kkel
    for(let i = pellets.length - 1; i >= 0; i--){
        const p = pellets[i];
        if(isNaN(p.x) || isNaN(p.y)){
            console.warn('Pellet koordinátái NaN, eltávolítás:', p);
            removeFromCell(p);
            pellets.splice(i, 1);
            pelletPool.push(p);
            continue;
        }
        const rsum1 = player1.radius + p.radius;
        if(dist2(player1.x, player1.y, p.x, p.y) < rsum1*rsum1){
            player1.radius = Math.min(MAX_PLAYER_RADIUS, player1.radius + p.radius * 0.6);
            removeFromCell(p);
            pelletPool.push(p);
            pellets.splice(i, 1);
            continue;
        }
        for(const npc of npcs){
            const rsum = npc.radius + p.radius;
            if(dist2(npc.x, npc.y, p.x, p.y) < rsum*rsum){
                npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + p.radius * 0.6);
                removeFromCell(p);
                pelletPool.push(p);
                pellets.splice(i, 1);
                break;
            }
        }
    }

    // Játékosok ételek és power-upok felvétele (optimalizált: queryNearby)
    function playerFoodAndPower(player){
        const q = queryNearby(player.x, player.y, player.radius + 8);
        for(const o of q){
            if(o.type === 'food'){
                const rsum = player.radius + o.radius;
                if(dist2(player.x, player.y, o.x, o.y) < rsum*rsum){
                    const grow = Math.max(0.5, 2 * (20 / Math.max(20, player.radius)));
                    player.radius = Math.min(MAX_PLAYER_RADIUS, player.radius + grow);
                    player.score++;
                    moveToRandomFood(o);
                }
            } else if(o.type === 'power'){
                const rsum = player.radius + o.radius;
                if(dist2(player.x, player.y, o.x, o.y) < rsum*rsum){
                    applyPowerupToPlayer(player, o);
                    removeFromCell(o);
                    const idx = powerups.indexOf(o);
                    if(idx >= 0) powerups.splice(idx, 1);
                    powerupPool.push(o);
                }
            }
        }
    }
    playerFoodAndPower(player1);
    
    // NPC-k ételek és power-upok felvétele
function handleNPCPickup(npc) {
    const q = queryNearby(npc.x, npc.y, npc.radius + 8);
    for (const o of q) {
        const rsum = npc.radius + o.radius;
        if (dist2(npc.x, npc.y, o.x, o.y) >= rsum * rsum) continue;

        if (o.type === 'food') {
            const grow = Math.max(0.5, 2 * (20 / Math.max(20, npc.radius)));
            npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + grow);
            npc.score++;
            moveToRandomFood(o);
        }

        else if (o.type === 'power') {
            if (o.kind === 'mass') {
                npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + 6);
            }
            else if (o.kind === 'dot') {
                npc.score += 1;
            }
            else if (o.kind === 'power') {
                // NPC-specifikus extra bónusz
                npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + 3);
                npc.baseSpeed = Math.min(npc.baseSpeed + 0.5, 6);
            }
            else if (o.kind === 'fruit') {
                npc.score += 100;
            }
            else if (o.kind === 'speed') {
				if (!npc.speedBoostActive) { // csak akkor, ha nincs már boost
					npc.speedBoostActive = true;
					npc.baseSpeed *= 1.5; // pl. 50%-kal gyorsabb
					setTimeout(() => {
						npc.baseSpeed /= 1.5; // visszaállítás
						npc.speedBoostActive = false;
					}, 5000); // 5 másodpercig tart
				}
			}
            else if (o.kind === 'shield') {
                npc.shieldActive = true;
                npc.shieldTimer = Date.now();
                setTimeout(() => npc.shieldActive = false, 5000); // 5 mp-ig tart
            }

            // Tárgy eltávolítása a pályáról
            removeFromCell(o);
            const idx = powerups.indexOf(o);
            if (idx >= 0) powerups.splice(idx, 1);
            powerupPool.push(o);
        }
    }
}

    const npcsToRemove = [];
    const newNpcs = [];
    for(let i = npcs.length - 1; i >= 0; i--){
        const npc = npcs[i];
        if(isNaN(npc.x) || isNaN(npc.y)){
            console.warn('NPC koordinátái NaN ütközéskezeléskor, visszaállítás:', npc);
            npcsToRemove.push(i);
            newNpcs.push(makeNPC());
            continue;
        }
        
        // Játékosokkal való ütközés
        const dx = player1.x - npc.x;
        const dy = player1.y - npc.y;
        const d2 = dx*dx + dy*dy;
        const rsum = player1.radius + npc.radius;
        if(d2 > 0 && d2 < rsum*rsum){
            const dist = Math.sqrt(d2);
            if(dist > 0.001){ // Nulla osztás elkerülése
                if(player1.radius > npc.radius + 6){
                    player1.radius = Math.min(MAX_PLAYER_RADIUS, player1.radius + Math.floor(npc.radius*0.6));
                    player1.score += 5;
                    npcsToRemove.push(i);
                    newNpcs.push(makeNPC());
                } else if(npc.radius > player1.radius + 6){
                    npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + Math.floor(player1.radius*0.6));
                    npc.score += 5;
                    resetPlayerTo(player1, worldWidth*0.25, worldHeight*0.5);
                } else {
                    const overlap = (rsum - dist);
                    const nx = dx / dist, ny = dy / dist;
                    player1.x += nx * overlap * 0.5;
                    player1.y += ny * overlap * 0.5;
                    npc.x -= nx * overlap * 0.5;
                    npc.y -= ny * overlap * 0.5;
                }
            }
        }
        
        // NPC-k egymással való ütközése
        for(let j = npcs.length - 1; j > i; j--){
            const other = npcs[j];
            if(isNaN(other.x) || isNaN(other.y)){
                console.warn('Másik NPC koordinátái NaN, visszaállítás:', other);
                npcsToRemove.push(j);
                newNpcs.push(makeNPC());
                continue;
            }
            const dx = other.x - npc.x;
            const dy = other.y - npc.y;
            const d2 = dx*dx + dy*dy;
            const rsum = npc.radius + other.radius;
            if(d2 > 0 && d2 < rsum*rsum){
                const dist = Math.sqrt(d2);
                if(dist > 0.001){ // Nulla osztás elkerülése
                    if(npc.radius > other.radius + 6){
                        npc.radius = Math.min(MAX_PLAYER_RADIUS, npc.radius + Math.floor(other.radius*0.6));
                        npc.score += 3;
                        npcsToRemove.push(j);
                        newNpcs.push(makeNPC());
                    } else if(other.radius > npc.radius + 6){
                        other.radius = Math.min(MAX_PLAYER_RADIUS, other.radius + Math.floor(npc.radius*0.6));
                        other.score += 3;
                        npcsToRemove.push(i);
                        newNpcs.push(makeNPC());
                        break;
                    } else {
                        const overlap = (rsum - dist);
                        const nx = dx / dist, ny = dy / dist;
                        npc.x -= nx * overlap * 0.5;
                        npc.y -= ny * overlap * 0.5;
                        other.x += nx * overlap * 0.5;
                        other.y += ny * overlap * 0.5;
                    }
                }
            }
        }
    }
    
    // NPC-k eltávolítása és újak hozzáadása
    for(const i of npcsToRemove){
        npcs.splice(i, 1);
    }
    npcs.push(...newNpcs);
}

function handlePlayerPickup(player){
    // merged in checkCollisions via helper
}

/* ---------- POWERUP EFFECTS ---------- */
function applyPowerupToPlayer(player, powerObj){
    if(powerObj.kind === 'speed'){
        player.boostUntil = nowMs() + 5000;
        player.boost = 1.6;
    } else if(powerObj.kind === 'shield'){
        // simple flash effect representing shield (we won't implement full invulnerability)
        player.flashUntil = nowMs() + 2000;
    } else if(powerObj.kind === 'mass'){
        player.radius = Math.min(MAX_PLAYER_RADIUS, player.radius + 6);
    }
}

/* ---------- helper respawn food ---------- */
function moveToRandomFood(foodObj){
    // just reposition and move cell
    const r = 5;
    const nx = r + Math.random()*(worldWidth - 2*r);
    const ny = r + Math.random()*(worldHeight - 2*r);
    moveToCell(foodObj, nx, ny);
}

/* ---------- CAMERA ---------- */
let camX = 0, camY = 0;
const CAMERA_LERP = 0.16;
function updateCamera(dt){
    const tx = player1.x - canvas.width/2;
    const ty = player1.y - canvas.height/2;
    const maxCamX = Math.max(0, worldWidth - canvas.width);
    const maxCamY = Math.max(0, worldHeight - canvas.height);
    const cx = clamp(tx, 0, maxCamX);
    const cy = clamp(ty, 0, maxCamY);
    camX += (cx - camX) * CAMERA_LERP;
    camY += (cy - camY) * CAMERA_LERP;
}

/* ---------- DRAW ---------- */
function draw(remainingMs){
    console.log('Rajzolás, NPC-k száma:', npcs.length);
    ctx.fillStyle = '#0d0d0d';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid lines subtle
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    const gridSize = 60;
    const startX = Math.floor(camX / gridSize) * gridSize;
    const endX = camX + canvas.width;
    for(let x=startX;x<=endX;x+=gridSize){
        const sx = Math.round(x - camX);
        ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,canvas.height); ctx.stroke();
    }
    const startY = Math.floor(camY / gridSize) * gridSize;
    const endY = camY + canvas.height;
    for(let y=startY;y<=endY;y+=gridSize){
        const sy = Math.round(y - camY);
        ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(canvas.width,sy); ctx.stroke();
    }

    // draw foods (only on-screen)
    ctx.fillStyle = 'gold';
    for(const f of foods){
        const sx = f.x - camX;
        const sy = f.y - camY;
        if(sx + f.radius < 0 || sx - f.radius > canvas.width || sy + f.radius < 0 || sy - f.radius > canvas.height) continue;
        ctx.beginPath(); ctx.arc(sx,sy,f.radius,0,Math.PI*2); ctx.fill();
    }

    // powerups
    for(const p of powerups){
        const sx = p.x - camX, sy = p.y - camY;
        if(sx + p.radius < 0 || sx - p.radius > canvas.width || sy + p.radius < 0 || sy - p.radius > canvas.height) continue;
        ctx.beginPath();
        if(p.kind==='speed') ctx.fillStyle = '#3af';
        else if(p.kind==='shield') ctx.fillStyle = '#ffb';
        else ctx.fillStyle = '#9f3';
        ctx.arc(sx,sy,p.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='black'; ctx.font='10px Arial'; ctx.fillText(p.kind[0].toUpperCase(), sx-4, sy+3);
    }

    // pellets
    ctx.fillStyle = '#ccc';
    for(const p of pellets){
        const sx = p.x - camX, sy = p.y - camY;
        if(sx + p.radius < 0 || sx - p.radius > canvas.width || sy + p.radius < 0 || sy - p.radius > canvas.height) continue;
        ctx.beginPath(); ctx.arc(sx,sy,p.radius,0,Math.PI*2); ctx.fill();
    }

    // fragments
    for(const f of fragments){
        const sx = f.x - camX, sy = f.y - camY;
        if(sx + f.radius < 0 || sx - f.radius > canvas.width || sy + f.radius < 0 || sy - f.radius > canvas.height) continue;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(120,170,255,0.95)'; // Csak player1 fragmentumok
        ctx.arc(sx,sy,f.radius,0,Math.PI*2); ctx.fill();
    }
    
    // NPC-k
    for(const npc of npcs){
        console.log(`NPC rajzolása: x=${npc.x}, y=${npc.y}`);
        const sx = npc.x - camX, sy = npc.y - camY;
        if(sx + npc.radius < 0 || sx - npc.radius > canvas.width || sy + npc.radius < 0 || sy - npc.radius > canvas.height) {
            console.log('NPC kívül esik a vásznon:', npc);
            continue;
        }
        ctx.beginPath();
        ctx.fillStyle = npc.color;
        ctx.arc(sx,sy,npc.radius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='white'; ctx.font='10px Arial'; ctx.fillText('NPC', sx-10, sy+3);
    }

    // players
    const now = nowMs();
    // player1
    const p1sx = player1.x - camX, p1sy = player1.y - camY;
    ctx.beginPath();
    ctx.fillStyle = (player1.flashUntil > now ? (Math.floor(now/100) % 2 ? 'white' : 'blue') : 'blue');
    ctx.arc(p1sx,p1sy,player1.radius,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText('J1', p1sx-8, p1sy+4);

    // HUD overlay on canvas
    ctx.fillStyle='white'; ctx.font='16px Arial';
    ctx.fillText(`J1: ${player1.score}`, 10, 22);
    const remainingSec = Math.max(0, (gameTimeMs - (now - startTime))/1000).toFixed(1);
    ctx.fillText(`Idő: ${remainingSec}s`, canvas.width/2 - 40, 22);
}

/* ---------- MINIMAP ---------- */
function drawMinimap(){
    const mm = minimapEl;
    const mmW = mm.clientWidth, mmH = mm.clientHeight;
    const mmCtx = mm._ctx || (mm._ctx = document.createElement('canvas').getContext('2d'));
    // create internal canvas same size
    if(!mm._canvas){ mm._canvas = document.createElement('canvas'); mm._canvas.width = mmW; mm._canvas.height = mmH; mm._ctx = mm._canvas.getContext('2d'); }
    const c = mm._ctx;
    mm._canvas.width = mmW; mm._canvas.height = mmH;
    // background
    c.fillStyle = 'rgba(10,10,10,0.9)'; c.fillRect(0,0,mmW,mmH);
    // scale
    const sx = mmW / worldWidth, sy = mmH / worldHeight;
    // foods (sample some for speed)
    c.fillStyle = 'gold';
    const sample = 200;
    for(let i=0;i<sample && i<foods.length;i++){
        const f = foods[i* Math.floor(Math.max(1, foods.length/sample))];
        c.fillRect(f.x * sx, f.y * sy, 1,1);
    }
    // powerups
    for(const p of powerups){ c.fillStyle = p.kind==='speed' ? '#3af' : p.kind==='shield' ? '#ffb' : '#9f3'; c.fillRect(p.x * sx, p.y * sy, 3,3); }
    // NPC-k
    for(const npc of npcs){
        c.fillStyle = npc.color;
        c.beginPath(); c.arc(npc.x * sx, npc.y * sy, Math.max(2, npc.radius*sx), 0, Math.PI*2); c.fill();
    }
    // players
    c.fillStyle='blue'; c.beginPath(); c.arc(player1.x * sx, player1.y * sy, Math.max(2, player1.radius*sx), 0, Math.PI*2); c.fill();
    // camera rect
    c.strokeStyle='rgba(255,255,255,0.5)'; c.strokeRect(camX*sx, camY*sy, canvas.width*sx, canvas.height*sy);
    // render to DOM element background
    mm.style.backgroundImage = `url(${mm._canvas.toDataURL()})`;
}

/* ---------- SCOREBOARD ---------- */
function updateScoreboard(){
    const items = [
        {name:'J1', score:player1.score, size: int(player1.radius)}
    ];
    
    // NPC-k hozzáadása a scoreboardhoz
    for(const npc of npcs){
        items.push({name:'NPC', score:npc.score, size: int(npc.radius)});
    }
    
    items.sort((a,b)=>b.size - a.size);
    sbEl.innerHTML = 'Top: —<br>' + items.map(it=>`${it.name} — méret: ${it.size} / pont: ${it.score}`).join('<br>');
    score1El.textContent = player1.score;
}

/* ---------- CAMERA FOLLOW & GAME TIMER ---------- */
let gameTimeMs = 420_000; // 7 perc
let startTime = nowMs();

/* ---------- MAIN LOOP ---------- */
let lastTime = nowMs();
function loop(ts){
    if(paused){ lastTime = ts; requestAnimationFrame(loop); return; }
    const dt = ts - lastTime; lastTime = ts;

    // input: movement for players
    applyInputs(dt);

    // update entities physics
    updateEntities(dt);

    // spawn powerups occasionally
    if(Math.random() < 0.0025) spawnPowerup(); // rate tuned

    // collisions & pickups
    checkCollisions();

    // camera
    updateCamera(dt);

    // draw
    const elapsed = nowMs() - startTime;
    const remainingMs = Math.max(0, gameTimeMs - elapsed);
    draw(remainingMs);
    drawMinimap();
    updateScoreboard();

    // check end
    if(remainingMs <= 0){
        paused = true;
        setTimeout(()=> alert(`Játék vége! J1: ${player1.score}`), 20);
        return;
    }
    requestAnimationFrame(loop);
}

/* ---------- INPUT APPLICATION ---------- */
function applyInputs(dt){
    // player1
    const dir1 = getInputDirection();
    const mag1 = Math.hypot(dir1.x, dir1.y);
    if(mag1 > 0){
        const speed = effectiveSpeed(player1);
        player1.x += (dir1.x/mag1) * speed * (dt/16.6667);
        player1.y += (dir1.y/mag1) * speed * (dt/16.6667);
    }

    // clamp players in world
    player1.x = clamp(player1.x, player1.radius, worldWidth - player1.radius);
    player1.y = clamp(player1.y, player1.radius, worldHeight - player1.radius);

    // boosts expire
    const now = nowMs();
    if(player1.boostUntil < now) { player1.boost = 1; player1.boostUntil = 0; }

    // actions: split/eject
    // player1: space -> split, q -> eject
    if(keys['space']){ keys['space'] = false; doSplit(player1); }
    if(keys['q']){ keys['q'] = false; doEject(player1); }

    // gamepad buttons for split/eject (poll)
    if(haveGamepad){
        const gp = navigator.getGamepads()[0];
        if(gp){
            if(gp.buttons[0] && gp.buttons[0].pressed) { doSplit(player1); } // A
            if(gp.buttons[1] && gp.buttons[1].pressed) { doEject(player1); } // B
        }
    }
}

/* ---------- RESET & START ---------- */
function resetPlayerTo(player, x, y){
    player.x = x; player.y = y; player.radius = 20; player.score = Math.max(0, player.score-3);
}

function startGame(){
    // reset world/grid
    initGrid();
    // ensure pool sizes
    if(foodPool.length < foodCount) {
        const need = foodCount - foodPool.length;
        for(let i=0;i<need;i++) foodPool.push({type:'food', x:0,y:0,radius:5,_cell:-1});
    }
    spawnFoods(foodCount);
    // clear pellets/frags/powerups pools/mappings
    for(const p of pellets){ if(p._cell>=0) removeFromCell(p); pelletPool.push(p); }
    pellets.length=0;
    for(const f of fragments){ if(f._cell>=0) removeFromCell(f); fragmentPool.push(f); }
    fragments.length=0;
    for(const p of powerups){ if(p._cell>=0) removeFromCell(p); powerupPool.push(p); }
    powerups.length=0;
    // reset players
    player1 = makePlayer(worldWidth*0.25, worldHeight*0.5,'blue');
    player1.score = 0;
    // NPC-k inicializálása
    initNPCs();
    startTime = nowMs();
    paused = false;
    lastTime = nowMs();
    requestAnimationFrame(loop);
}

startGame();

/* ---------- DEBUG shortcuts ---------- */
window.addEventListener('keydown',(e)=>{
    if(e.key === 'p'){ paused = !paused; }
    if(e.key === 'g'){ GRID_SIZE = Math.max(80, GRID_SIZE - 20); initGrid(); spawnFoods(foodCount); 
        // Re-add NPCs to grid
        for(const npc of npcs) { npc._cell = -1; addToCell(npc); }
    }
    if(e.key === 'h'){ GRID_SIZE = GRID_SIZE + 20; initGrid(); spawnFoods(foodCount); 
        // Re-add NPCs to grid
        for(const npc of npcs) { npc._cell = -1; addToCell(npc); }
    }
});
</script>
</body>
</html>
